// This file provides server-side loading of business profiles for content-based filtering
const fs = require('fs');
const path = require('path');
const csv = require('csv-parser');

// Simulated data folder containing pre-computed business profiles
const DATA_DIR = path.join(process.cwd(), 'data');

/**
 * Load pre-computed business profiles for content-based filtering
 * In a real implementation, this would load from cache files generated by Python
 * @returns {Object} A map of business IDs to feature vectors 
 */
function loadBusinessProfiles() {
  try {
    console.log('Loading business profiles for content-based filtering');
    
    // In a real implementation, this would load actual embeddings and sentiment scores
    // Here we're creating synthetic data based on restaurant attributes
    
    const profiles = {};
    const restaurantsPath = path.join(DATA_DIR, 'restaurants.csv');
    
    // Simple synchronous parsing to avoid complexity
    const restaurants = [];
    fs.createReadStream(restaurantsPath)
      .pipe(csv())
      .on('data', (row) => restaurants.push(row))
      .on('end', () => {
        console.log(`Loaded ${restaurants.length} restaurants for creating profiles`);
      });
      
    // Create synthetic profiles for each restaurant
    restaurants.forEach(restaurant => {
      // Extract features to use for the profile
      const rating = parseFloat(restaurant.rating || 0);
      const reviewCount = parseInt(restaurant.review_count || 0, 10);
      const price = restaurant.price ? restaurant.price.length : 0; // Convert $ to 1, $$ to 2, etc.
      
      // Create categories array from comma-separated string
      const categories = (restaurant.categories || '')
        .split(',')
        .map(c => c.trim())
        .filter(Boolean);
      
      // Generate a synthetic embedding vector (in real implementation, this would be from NLP)
      // Each position roughly corresponds to a latent semantic feature
      const syntheticEmbedding = [
        rating / 5.0,  // Normalized rating
        Math.min(1.0, reviewCount / 1000),  // Normalized review count
        price / 4.0,  // Normalized price
        categories.includes('Restaurant') ? 1.0 : 0.0,
        categories.includes('Bar') ? 1.0 : 0.0,
        categories.includes('Food') ? 1.0 : 0.0,
        categories.includes('Italian') ? 1.0 : 0.0,
        categories.includes('Mexican') ? 1.0 : 0.0,
        categories.includes('Chinese') ? 1.0 : 0.0,
        categories.includes('American') ? 1.0 : 0.0,
        categories.includes('Japanese') ? 1.0 : 0.0,
        categories.includes('Cafe') ? 1.0 : 0.0,
        Math.random() * 0.5  // Add some randomness for diversity
      ];
      
      // Add a synthetic sentiment score (in real implementation, this would be from sentiment analysis)
      const syntheticSentiment = (Math.min(5, rating + 0.5) / 5.0) * 2 - 1; // Convert to -1 to 1 range
      
      // Store the complete feature vector
      profiles[restaurant.id] = [...syntheticEmbedding, syntheticSentiment];
    });
    
    return profiles;
  } catch (error) {
    console.error('Error loading business profiles:', error);
    return {};
  }
}

/**
 * Get most similar businesses to a given business using cosine similarity
 * @param {string} businessId - The business ID to find similar businesses for
 * @param {Object} profiles - The business profiles
 * @param {number} topN - Number of similar businesses to return
 * @returns {Array} Array of similar business IDs
 */
function getSimilarBusinesses(businessId, profiles, topN = 5) {
  try {
    const targetProfile = profiles[businessId];
    if (!targetProfile) {
      console.error(`Business ID ${businessId} not found in profiles`);
      return [];
    }
    
    // Calculate similarity with all other businesses
    const similarities = [];
    for (const [id, profile] of Object.entries(profiles)) {
      if (id === businessId) continue;
      
      // Calculate cosine similarity
      const similarity = calculateCosineSimilarity(targetProfile, profile);
      similarities.push({ id, similarity });
    }
    
    // Sort by similarity and return top N
    return similarities
      .sort((a, b) => b.similarity - a.similarity)
      .slice(0, topN)
      .map(item => item.id);
  } catch (error) {
    console.error('Error getting similar businesses:', error);
    return [];
  }
}

/**
 * Calculate cosine similarity between two vectors
 * @param {Array} vecA - First vector
 * @param {Array} vecB - Second vector
 * @returns {number} Cosine similarity
 */
function calculateCosineSimilarity(vecA, vecB) {
  if (vecA.length !== vecB.length) return 0;
  
  let dotProduct = 0;
  let normA = 0;
  let normB = 0;
  
  for (let i = 0; i < vecA.length; i++) {
    dotProduct += vecA[i] * vecB[i];
    normA += vecA[i] * vecA[i];
    normB += vecB[i] * vecB[i];
  }
  
  // Prevent division by zero
  if (normA === 0 || normB === 0) return 0;
  
  return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));
}

// Export functions for API routes
module.exports = {
  loadBusinessProfiles,
  getSimilarBusinesses
}; 